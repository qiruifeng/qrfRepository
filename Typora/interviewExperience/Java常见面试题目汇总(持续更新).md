[toc]

### 计算机网络

#### 1、OSI七层模型与TCP/IP 五层模型,

底层物理层、数据链路层、网络层（IP及路由选择）、传输层（端到端连接）一致，上层的应用层 = 会话层（建立、管理会话）+表示层（数据协议与加密）+应用层（提供服务）

#### 2、常见应用层协议和运输层、网络层协议，以及硬件如路由器之类在哪一层


三种常见的应用层协议：HTTP、FTP、SMTP
传输层协议：传输控制协议TCP、用户数据报协议UDP
网络层有四个协议：ARP协议，IP协议，ICMP协议，IGMP协议。

集线器工作在物理层，交换机工作在数据链路层，路由器工作在网络层。

#### 3、TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些

有连接、无连接；可靠、不可靠；慢、快

#### 4、TCP可靠传输的保证，拥塞控制目的和过程

3次握手+4次挥手，有连接的方式保证可靠传输
拥塞控制避免长时间等待以及包乱序问题，使用拥塞队列的方式，采用互动列表读取队列数据

#### 5、TCP粘包现象原因和解决方法

粘包表示不同的数据包整合到一起，出现边界不清的问题
采用指定长度+定长的方式解决类似问题

#### 6、TCP三次握手过程以及每次握手后的状态改变，为什么三次？为什么两次不行？如果你的答案是防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源，但这个答案被否定了，你还能给出什么答案？

确保对方有收到包

#### 7、TCP四次挥手过程以及状态改变，为什么四次？CLOSE-WAIT和TIME-WAIT存在的意义？如何查看TIME-WAIT状态的链接数量？为什么会TIME-WAIT过多？解决方法是怎样的？

回忆那张图。
close-wait的存在是为了关闭表现层，等待表现层结束，time-wait是出于担心：server没有收到 client发送的 对server关闭连接请求的 回包；而再次发送关闭请求，此时client处于time-wait状态，还能继续收包并回复确定。
 netstat -an | awk '/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}'
如果使用了nginx代理，那么系统TIME_WAIT的数量会变得比较多，这是由于nginx代理使用了短链接的方式和后端交互的原因，使得nginx和后端的ESTABLISHED变得很少而TIME_WAIT很多，目前看来最好的办法是让每个TIME_WAIT早点过期

#### 8、TCP、UDP、IP、以太网报文格式以及重要字段，报文从一端到另一端传递的过程。

#### 9、浏览器输入URL并回车的过程以及相关协议，DNS查询过程。

浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址。
解析出ip地址后，根据IP地址和默认端口，和服务器建立TCP连接。
浏览器发出读取文件（URL域名后面的部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文传送给服务器。
服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器。
释放TCP链接。
浏览器将该html文本显示内容

先去本地 hosts 中找对应地址

再去域名解析器(缓存)中寻找映射关系

找DNS 服务器问是不是配置在其下的

DNS 服务器有没有缓存它的映射关系

DNS 根据配置去找到根服务器或者上一级 DNS 服务器



#### 10、HTTP1.0、1.1、2.0之间的区别



#### 11、HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？



HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题

HTTPS的连接建立在TCP连接之上，加入了SSL/TSL(加密、解密)的过程：
在使用HTTPS是需要保证服务端配置正确了对应的安全证书
客户端发送请求到服务端
服务端返回公钥和证书到客户端
客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端
服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密
客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户
SSL加密建立

对称加密：即加密的密钥和解密的密钥相同
非对称加密：非对称加密将密钥分为公钥和私钥,公钥可以公开,私钥需要保密,客户端公钥加密的数据,服务端可以通过私钥来解密

#### 12、HTTP请求有哪些，多说点。Post和get区别。

GET方法、POST方法、HEAD方法、PUT方法、DELETE方法、CONNECT方法、OPTIONS方法、TRACE方法

#### 13、HTTP常见响应状态码，从1xx到5xx都要说。如304,301,302，504，

#### 14、重定向和转发区别

#### 15、cookie和session区别。

### 操作系统：

#### 1、进程和线程的区别

进程：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程
线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。

与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程

#### 2、协程呢？

协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。
一个进程可以包含多个线程，一个线程可以包含多个协程。
一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。
协程与进程一样，切换是存在上下文切换问题的。

#### 3、进程间通信方式IPC


管道：pip，一般在Linux手动操作的时候使用
信号：segment，没用过
消息队列
共享内存：最快速的通信方式，速度很快，通过file来配置共享内存，然后去加载，使用的最多
本地套接字：由于能从函数上和网络套接字实现整合，所以使用的也很多，通过封装能让程序开发中不用考虑数据流通是网络还是本地

#### 4、用户态和核心态

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

#### 5、操作系统分配的进程空间是怎样的？线程能共享哪些？

进程的内存线程都能共享到，而线程之间存在互斥关系。
进程贡献的空间包括：堆、全局变量、静态变量以及公共文件
线程自己会生成：线程ID，线程代码计数器，线程堆栈，错误返回码，线程优先级，线程信号屏蔽码等线程专属的内存空间

#### 6、操作系统内存管理方式，分页分段以及段页式的优缺点


内存管理方式主要分为：页式管理、段式管理和段页式管理。

页式管理的基本原理是将各进程的虚拟空间划分为若干个长度相等的页。把内存空间按页的大小划分为片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表，并用相应的硬件地址转换机构来解决离散地址变换问题。页式管理采用请求调页和预调页技术来实现内外存存储器的统一管理。

优点：没有外碎片，每个内碎片不超过页的大小。

缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。

段式管理的基本思想是把程序按内容或过程函数关系分成段，每段有自己的名字。一个用户作业或者进程所包含的段对应一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址。

优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。

缺点：会产生碎片。

段页式管理，系统必须为每个作业或者进程建立一张段表以管理内存分配与释放、缺段处理等。另外由于一个段又被划分为若干个页，每个段必须建立一张页表以把段中的虚页变换为内存中的实际页面。显然与页式管理时相同，页表也要有相应的实现缺页中断处理和页面保护等功能的表项。

段页式管理是段式管理和页式管理相结合而成，具有两者的优点。

由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。

#### 7、页面置换算法有哪些，FIFO为什么不好？如何改进?LRU思想，手写LRU


1.先进先出置换算法（FIFO）：是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。
2．最佳置换算法（OPT）（理想置换算法）：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。
3．最近最久未使用（LRU）算法：这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。

#### 8、死锁条件，解决方式。

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不可剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 环路等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

1.尽量避免线程请求多个共享资源
2.设置线程超时，当线程请求超时时，释放自己占用的资源
3.设置多个共享资源的编号，原则上的意义是当资源的请求实现原子性，也就是不很割裂请求

### Java基础

#### 1、面向对象特性介绍、与C++区别


面向对象的特点就是封装、继承、多态。
C++可以继承多个类，继承之后就拥有了所有子类的属性和方法。Java只能继承自一个类，但可以实现多个接口。
C++方法的晚绑定是通过虚函数实现。
虚函数又分为纯虚函数和虚函数，定义纯虚函数的类可以不实现它，而交给子类区实现，定义虚函数的类需要同时实现它。
无论是虚函数还是纯虚函数，编译器在编译时，不会直接决定该执行哪一个函数，而是通过虚函数表中的函数指针去调用。如此实现了对象方法调用的晚绑定。
Java的除了private方法和static之外的所有方法均为晚绑定，所以Java中没有虚函数的概念。

#### 2、多态实现原理


多态的实现依靠的是继承，子类继承父类的功能函数并定制化函数

#### 3、抽象类和接口区别，以及各自的使用场景

 interface的应用场合
类与类之前需要特定的接口进行协调，而不在乎其如何实现。
作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

 abstract class的应用场合
一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：

定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能

#### 4、泛型以及泛型擦除。List<A>类型的list,可以加入无继承关系的B类型对象吗？如何加入？

#### 5、Java异常体系

#### 6、反射原理以及使用场景

#### 7、ThreadLocal原理，如何使用？

#### 8、内存泄漏的场景

#### 9、static关键字和final关键字使用情况，一个类不能被继承，除了final关键字之外，还有什么方法（从构造函数考虑）？

静态（static）：
1、调用静态方法：1、对象名.静态方法；2、类名.静态方法
可以被本包下的类，子包下的类，本项目下的其他包的类调用
2、调用静态属性：1、对象名.静态属性；2、类名.静态属性
可以被本包下的类调用，其他包的类不能调用
3、调用公共方法：1、对象名.方法；2、类名.方法
可以被本包下的类，子包下的类，本项目下的其他包的类调用
4、调用公共方法：1、对象名.方法；2、类名.方法
可以被本包下的类，子包下的类，本项目下的其他包的类调用
final
1、被final修饰的变量不可以被改变，又被称为常量
2、被final修饰的方法不可以被重写
3、被final修饰的类不可以被继承
final总结：不可变

除了final关键字外，可以采用构造函数私有化的方式，也就是单例模式实现的方式（单例模式要实现必须使用static初始化自己，意味着其构造函数也是static修饰，然后提供一个公有的get函数）



#### 10、序列化和反序列化。反序列化失败的场景。

把对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为对象的过程称为对象的反序列化。
协议变更会导致失败

#### 11、ArrayList和LinkedList的区别和底层实现？如何实现线程安全？

#### 12、List遍历时如何删除元素？fail—fast是什么？fail—safe是什么？

#### 13、详细介绍HashMap。角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N+JDK1.7与JDK1.8的区别。

#### 14、HashMap如何实现线程安全？ConcurrentHashMap的底层实现？JDK1.7与JDK1.8的区别

#### 15、正则表达式会写吗？

#### 16、设计模式了解吗？

#### 17、linux指令知道哪些？

### JVM相关

#### 1、JVM运行时内存划分？PC+虚拟机栈+本地方法栈+堆+方法区+JDK1.7与1.8区别

#### 2、堆内存分配策略

#### 3、Full GC触发条件

#### 4、如何判断对象是否存活？回收对象的两次标记过程。

#### 5、垃圾回收算法以及垃圾回收器介绍，尤其是G1和CMS的优缺点

#### 6、创建一个对象的步骤

#### 7、详细介绍类加载过程

#### 8、双亲委派机制，使用这个机制的好处？破坏双亲委派机制的场景？如何破坏？

#### 9、了解下tomcat的类加载机制

#### 10、JVM性能调优，常用命令，以及工具

### 多线程并发

#### 1、进程线程区别，线程安全和非线程安全区别


线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，是被系统独立调度和分派的基本单位。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。

线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory，一个线程对一个variable进行操作时，都要在自己的working memory里面建立一个copy，操作完之后再写入main memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。根据上面的解释，很容易想出相应的scenario。
而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你认为合适的object比如method，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完 load到workingmemory －> use&assign －> store到mainmemory 的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。

#### 2、线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别


yield：当前正在被服务的线程可能觉得cpu的服务质量不够好，于是提前退出
sleep()：使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会执行，不推荐使用，可用wait
wait()后，线程会释放掉它所占有的“锁标志”，从而使线程所在对象中的其它synchronized数据可被别的线程使用
waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在 synchronized函数或synchronized　block中进行调用
join()方法使当前线程停下来等待，直至另一个调用join方法的线程终止

#### 3、wait,notify阻塞唤醒确切过程？在哪阻塞，在哪唤醒？为什么要出现在同步代码块中，为什么要处于while循环中？

获得锁的线程调用wait，获得锁的线程调用notify

只有出现在同步代码块中才表示获得了锁，才能释放
当多个线程并发访问同一个资源的时候, 若消费者同时被唤醒,但是只有一个资源可用, 那么if会导致资源被用完后直接去获取资源(发生越界异常等),而while则会让每个消费者获取之前再去判断一下资源是否可用.可用则获取,不可用则继续wait住

#### 4、线程中断，守护线程

thread.interrupt()

t.setDaemon(true)为守护线程，也叫精灵线程，若主线程启动t线程,则t线程是主线程的守护线程，当主线程执行完了，则守护线程也随之结束。也就是说，只要是那个线程启动守护线程，守护线程就等待该线程直到执行结束。守护线程往往是给主线程清除障碍的，比如服务器的面临可能会有崩溃的情况，守护线程会提主线程监视服务器的运行情况

#### 5、Java乐观锁机制，CAS思想？缺点？是否原子性？如何保证？

<1>全称是compareAndSet，含义是比较并交换。
<2>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V

CAS想要进行赋值时，会拿原来的取的值和现在的值比较，但是仔细想万一这个值在我们取值之后，被别的线程改变了，但是紧接着又被别的线程改回来了，我们一比较没问题，是一样的，我们认为没人修改这个值，可以进行赋值，但是其实这个值以及被改变过来，这就是我们CAS中的 ABA 问题
当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作

#### 6、synchronized使用方法？底层实现？

#### 7、ReenTrantLock使用方法？底层实现？和synchronized区别？

#### 8、公平锁和非公平锁区别？为什么公平锁效率低？

#### 9、锁优化。自旋锁、自适应自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、重量级锁解释

#### 10、Java内存模型

#### 11、volatile作用？底层实现？禁止重排序的场景？单例模式中volatile的作用？

#### 12、AQS思想，以及基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍

AQS，既AbstractQueuedSynchronizer, 是JUC包实现同步的基础工具，是一个抽象类。在AQS中，定义了一个volatile int state变量作为共享资源，并且内置自旋锁实现的同步队列，封装入队和出队的操作，提供独占、共享、中断等特性的方法。

如果线程获取资源失败，则进入同步FIFO（先进先出）队列中等待（入队）；
如果成功获取资源就执行临界区代码。
执行完释放资源时，通知队列中的等待线程来获取资源，然后出队。

AQS的子类可以定义不停的资源实现不同性质的方法

#### 13、线程池构造函数7大参数，线程处理任务过程，线程拒绝策略

#### 14、Execuors类实现的几种线程池类型，阿里为啥不让用？

#### 15、线程池大小如何设置？

#### 16、手写简单的线程池，体现线程复用

#### 17、手写消费者生产者模式（threadtest, PublicQueue, ProducerThread, ConsumerThread）

#### 18、手写阻塞队列

（快手、MyselfBlockQueue）

#### 19、手写多线程交替打印ABC（快手、StrangePrinter）

### MySQL

#### 1、事务4大特性，一致性具体指什么？这4个特性mysql如何保证实现的？

#### 2、事务隔离级别，4个隔离级别分别有什么并发问题？

#### 3、Mysql默认隔离级别？如何保证并发安全？

#### 4、RR和RC如何实现的？RR使用场景？对比volatile可见性，为什么RR的事务要设计成不能读另一个事务已经提交的数据？



#### 5、隔离级别的单位是数据表还是数据行？如串行化级别，两个事务访问不同的数据行，能并发？

#### 6、存储引擎Innodb和Myisam的区别以及使用场景

#### 7、 介绍Inodb锁机制，行锁，表锁，意向锁

#### 8、介绍MVCC.

#### 9、哈希索引是如何实现的？

#### 10、B树索引为什么使用B+树，相对于B树有什么优点？为什么不能红黑树？要提到磁盘预读

#### 11、聚簇索引和非聚簇索引区别

#### 12、回表查询和覆盖索引

#### 13、如何创建索引？

#### 14、如何使用索引避免全表扫描？

#### 15、Explain语句各字段的意义

#### 16、最左前缀！！联合索引B+树是如何建立的？是如何查询的？当where子句中出现>时，联合索引命中是如何的? 如 where a > 10 and b = “111”时，联合索引如何创建？mysql优化器会针对得做出优化吗？

#### 17、MySQL中一条SQL语句的执行过程

#### 18、数据库几大范式

#### 19、数据库基本查询关键字使用，如left join on,where,beteen and,group by,having,limit,聚合函数等。

#### 20、left join,right join,inner join,outer join的含义及区别

#### 21、mysql主从复制过程，binlog记录格式，复制的异步半同步同步模式区别

#### 22、主从复制或读写分离等数据不一致性问题以及如何解决

#### 23、银行的话，可以会考mysql数据类型，如余额要用decimal

### Redis问题：

#### 1、为什么使用Redis


提升服务器性能方面非常有效，将数据持久化的工作剥离出来交给Redis进行操作。

#### 2、分布式缓存和本地缓存有啥区别？让你自己设计本地缓存怎么设计？如何解决缓存过期问题？如何解决内存溢出问题？

分布式缓存一致性更好一点，本地缓存 每个实例都有自己的缓存，可能会存在不一致的情况。

本地缓存会占用堆内存，影响垃圾回收、影响系统性能。分布式缓存两大开销会导致其慢于本地缓存，网络延迟和对象序列化
进程内缓存适用于较小且频率可见的访问场景，尤其适用于不变对象，对于较大且不可预见的访问，最好采用分布式缓存。

将缓存失效时间分散开，不要所以缓存时间长度都设置成5分钟或者10分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件

自己设计考虑的点：
数据结构，也就是如何保存缓存数据
对象上限，针对内存有限性的必要考虑
清除策略，针对内存有限性的必要考虑，必须考虑回收内存的策略
过期时间，针对清除策略的必要考虑，定义那些缓存应该被回收
线程安全，针对多线程操作的必要考虑，可以针对数据结构进行add和remove的管理，使用读写锁的方式来保证一致性
简明的接口，缓存需要尽可能设计的简单
持久化，很多缓存内容需要持久化，同时需要考虑宕机，重启，进程迁移等问题进行数据持久化
阻塞机制

内存溢出通常是内存不够用，第一是加大内存，第二是避免内存不够用的时候分配内存

#### 3、redis和memcache的区别

#### 4、redis常用数据结构和使用场景

#### 5、Zset底层实现？跳表搜索插入删除过程？

#### 6、redis过期淘汰策略


定期删除+惰性删除
如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

#### 7、redis持久化机制？都有什么优缺点？持久化的时候还能接受请求吗？

Redis 提供两种持久化机制 RDB 和 AOF 机制:RDB也就是定时快照的方式，定时间隔长，数据丢失大，安全性差；AOF是每次命令都进行记录，会造成文件越来越大，回复速度慢

1、RDBRedis DataBase)持久化方式：是指用数据集快照的方式半持久化模式) 记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件。

持久化 结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。

优点：

1、只有一个文件 dump.rdb，方便持久化。

2、容灾性好，一个文件可以保存到安全的磁盘。

3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能)

4.相对于数据集大时，比 AOF 的启动效率更高。

缺点：

1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生 故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)

2、AOFAppend-only file)持久化方式：是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof 文件。

优点：

1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。

2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。

3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)

缺点：

1、AOF 文件比 RDB 文件大，且恢复速度慢。

2、数据集大的时候，比 rdb 启动效率低

#### 8、redis事务


Redis事务的概念：Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　

Redis事务没有隔离级别的概念：批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。
Redis不保证原子性：Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。Redis事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以开发者认为没有必要为Redis开发事务回滚功能

Redis事务的三个阶段：

开始事务
命令入队
执行事务
Redis事务相关命令：

　　watch key1 key2 ... : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）

　　multi : 标记一个事务块的开始（ queued ）

　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　

　　discard : 取消事务，放弃事务块中的所有命令

　　unwatch : 取消watch对所有key的监控

Redis事务使用案例：

（1）正常执行

（2）放弃事务

（3）若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行

（4）若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。

（5）使用watch

案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功

案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。

一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。

故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。

 总结：watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。

#### 9、缓存雪崩和缓存穿透，以及解决方法

缓存雪崩通常是数据大规模同时过期导致的，所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供，采用随机过期时间的方式设置过期时间
缓存穿透，是查询确定不存在的数据时产生的问题，该情况导致缓存失去意义
方法1.在封装的缓存SET和GET部分增加个步骤，如果查询一个KEY不存在，就已这个KEY为前缀设定一个标识KEY；以后再查询该KEY的时候，先查询标识KEY，如果标识KEY存在，就返回一个协定好的非false或者NULL值，然后APP做相应的处理，这样缓存层就不会被穿透。当然这个验证KEY的失效时间不能太长。（无数据标志位，存在不查询）

方法2.如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。（无数据也缓存）

方法3.采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。（有数据标志位，不存在不查询）

#### 10、如何保证缓存和数据库的数据一致性？

#### 11、redis是单线程还是多线程？为什么那么快？

单线程，内存执行，单线程，服用I/O接口

#### 12、五种IO模型的区别

1.阻塞IO模型
2.非阻塞IO模型
3.多路复用IO模型
4.信号驱动IO模型
5.异步IO模型

#### 13、select、poll、epoll的区别？

#### 14、redis热key问题？如何发现以及如何解决？

瞬间有几十万的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况
怎么发现热key
方法一:凭借业务经验，进行预估哪些是热key
其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。
方法二:在客户端进行收集
这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。
方法三:在Proxy层做收集
有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。
方法四:用redis自带命令
(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。
(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。
方法五:自己抓包评估
Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。

以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？

如何解决
目前业内的方案有两种
(1)利用二级缓存
比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。
针对这种热key请求，会直接从jvm中取，而不会走到redis层。
假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。
现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。
(2)备份热key
这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。
假设redis的集群数量为N，步骤如下图所示

#### 15、redis数据分布方式？有什么优点？一致性hash呢？

顺序分区，一致性hash分区

#### 16、redis主从复制，主从切换，集群

### Spring

#### 1、Spring IOC

#### 2、Spring AOP，动态***

#### 3、Bean生命周期

#### 4、Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?

#### 5、Spring事务隔离级别和事务传播属性

#### 6、Spring以及Spring MVC常见注解

#### 7、@autowired和@resource的区别，当UserDao存在不止一个bean或没有存在时，会怎样?怎么解决？

#### 8、mybatis如何防止sql注入？$#的区别是什么？传入表明用哪个？

#### 9、Spring MVC工作原理

#### 10、SpringBoot自动配置的原理是什么？介绍SpringBootApplication注解.

#### 11、Mybatis和Hibernate的区别

#### 12、spring中的注解原理？例如事务注解，spring如何根据注解实现事务功能的

#### 13、Spring中用到了哪些设计模式？单例、***、工厂、适配、观察者之类的说一说就行

### 大数据和空间限制与系统设计

#### 1、100亿黑名单URL，每个64B,判断一个URL是否在黑名单中

#### 2、2GB内存在20亿整数中找到出现次数最多的数

#### 3、40亿个非负整数中找到没有出现的数

#### 4、40亿个非负整数中找到一个没有出现的数，内存限制10MB

#### 5、找到100亿个URL中重复的URL

#### 6、海量搜索词汇，找到最热TOP100词汇的方法

#### 7、40亿个无符号整数，1GB内存，找到所有出现两次的数

#### 8、10MB内存，找到40亿整数的中位数

#### 9、设计短域名系统，将长URL转化成短的URL.(知乎老哥给出了答案，博客有人根据他的总结了一下，很好)

#### 10、让你系统的设计一个高并发的架构，你会从哪几个方面考虑？

#### 11、一个千万级的APP，你要搞定关注和粉丝列表，你用什么来做。要求最后一个关注的在最前面。新增和取关都要比较快的反馈你怎么做？如果一个人关注了之后，服务器宕机了怎么办？

#### 12、OOD design：计费停车场

#### 13、假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写

#### 14、显示网站的用户在线数的解决思路

### 项目


如果个人没有好的项目，就用高并发秒杀。B站搜高并发秒杀，有慕课网视频，讲的很好。Github搜秒杀，有代码，跑一遍。有时间自己写一遍，没时间就看懂就好。然后准备问题，不要求每个功能都实现的特别好，但一定要多考虑系统可能出现的问题，因为很多人都是这个项目，你考虑的多，自然就显得稍微那么好了点。

#### 1、如何解决超卖？mysql锁+redis预减库存+redis缓存卖完标记

#### 2、如何解决重复下单？mysql唯一索引+分布式锁

#### 3、如何防刷？IP限流+验证码

#### 4、热key问题如何解决？redis集群+本地缓存+限流+key加随机值分布在多个实例中

#### 5、消息队列的作用？如何保证消息的不丢失？异步削峰；发送方开启confirm+消息队列持久化+消费方关闭自动ACK,确保消费成功之后自动调用API进行确认。

#### 6、缓存和数据库数据一致性如何保证？秒杀项目不用保证，其他项目就用延时双删或者先更新数据再是缓存失效，为防缓存失效这一信息丢失，可用消息队列保护。

延时双删：（1）先淘汰缓存；

（2）再写数据库（这两步和原来一样）；

（3）休眠1秒，再次淘汰缓存；

这么做，可以将1秒内所造成的缓存脏数据，再次删除！



#### 7、压测没有？用什么压测？什么情况？

#### 8、系统瓶颈在哪？如何查找，如何再优化？