[TOC]

#### 1、Java最新版本

我们目前用的是Java8，目前我知道的最新的版本到14了

#### 2、JDK和JRE的区别

JDK 是 Java Development Kit他是功能齐全的Java SDK。它包含了JRE拥有的一切，一般是开发的时候需要的。而JRE是Java的运行环境。它是运行已编译Java程序所需的所有内容的集合，包括JVM,Java类库，Java命令和一些其他的基础构建，不能用来创建新的程序。

如果只是跑一下Java的代码的话，一般用JRE就可以了。但是也不是绝对的，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢?因为应用程序服务器会将JSP转
换为Java servlet,并且需要使用JDK来编译servlet。

#### 3、程序写好了，如何部署到服务器

以我们的项目为例，分为前端和后台。先说前端，我们本地用的vue框架来写前端代码，版本更新时，我们先在本地进行打包，在node环境下运行npm run build指令，会在项目的target目录下生成dist文件。然后我们把这一份dist文件夹下的所有文件，复制到服务器的nginx或者tomcat的html文件夹下，即可完成前端的部署。后台的部署就是本地打一个jar包，然后在服务器上直接运行jar包就好。

#### 4、抽象类和接口的区别，抽象类和接口能否实例

首先接口和抽象类都不能被实例化，只有被另一个类实现或者继承，才能使用。区别有以下几点：

1. 接口中除了static、 final 变量，不能有其他变量，而抽象类中则不一定。
2. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
3. 从设计层面来说，抽象是对类的抽象，是一一种模板设计，而接口是对行为的抽象，是一种行为的规范。

#### 5、静态方法和实例方法的区别

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。


#### 6、String、StringBuffer、 StringBuilder, 的区别。

1. 可变性。

   简单的来说: String 类中使用final 关键字修饰字符数组来保存字符串，private final char value []， 所以String对象是不可变的。而StringBuilder与StringBuffer 都继承自AbstractStringBuilder 类，在AbstractStringBuilder中也是使用字符数组保存字符串char []value但是没有用final关键字修饰，所以这两种对象都是可变的。

2. 线程安全性

   String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是StringBuilder
   与StringBuffer的公共父类，定义了一一些字符串的基本操作，如expandCapacity、append、 insert、
   indexOf等公共方法。**StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁**，所以是线程安全
   的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

#### 7、MySql数据表，查有多少条数据，怎么查，SQL语句(返回数据条数，数值)

用count关键字，比如[select](https://www.baidu.com/s?wd=select&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) count(*) [from](https://www.baidu.com/s?wd=from&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) test where id=1。

#### 8、final修饰的类能不能继承、使用?

不可以。

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改;如果是
   引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为
   final方法。
3. 使用final方法的原因有两个。**第一个原因是把方法锁定，以防任何继承类修改它的含义**;第二个原
   因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能
   看不到内嵌调用带来的任何性能提升(现在的Java版本已经不需要使用final方法进行这些优化
   了)。类中所有的private方法都隐式地指定为final.

#### 9、了解操作系统吗?进程间的通信方式?

1. 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。

2. 有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。

3. 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

4. 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。

6. 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。

7. 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。

#### 10、多线程用过吗?

待补充内容

#### 11、了解锁吗?锁用到哪个场景?说到了乐观锁、悲观锁，解释一下?怎么用的?

1. 乐观锁。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**

   乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。

   （1） 数据版本机制

   　　实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例。

   　　版本号方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

   （2） CAS操作

   　　CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

   　　CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。

2. 悲观锁。**悲观锁适合写操作非常多的场景**，比如Java里面的同步原语synchronized关键字的实现就是悲观锁。

   认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一份数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁并发操作一定会出问题。

#### 12、TCP、UDP了解吗? (为什么 TCP是可靠的，UDP 是不可靠的? )

1. TCP的特点

   TCP**提供面向连接的服务**。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务(**TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源)**，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP - -般用于文件传输、发送和接收邮件、远程登录等场景。

2. UDP的特点

   UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一一种最有效的工作方式(- -般用于即时通信)，比如: QQ语音、QQ视频、直播等等

#### 13、解释一下TCP的三次握手?第一次发送的SYN码?断开的过程

1. TCP三次握手

   第一次握手：客户端--->发送带有SYN标志的数据包--->一次握手服务端--->服务端

   第二次握手：服务端--->发送带有SYN/ ACK标志的数据包--->二次握手--->客户端

   第三次握手：服务端--->发送带有SYN/ ACK标志的数据包--->二次握手--->客户端

2. 断开四次挥手的过程

   第一次挥手：客户端-发送一个FIN,用来关闭客户端到服务器的数据传送

   第二次挥手：服务器-收到这个FIN,它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号

   第三次挥手：服务器关闭与客户端的连接，发送一个FIN给客户端

   第四次挥手：客户端-发回ACK报文确认，并将确认序号设置为收到序号加1

3. 为什么要四次挥手

   任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没
   有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

   举个例子: A和B打电话，通话即将结束后，A说“我没啥要说的了”，B回答"我知道了”，但是B可能还会有要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说“我说完了”，A回答“知道了”，这样通话才算结束。

4. 第一次发送的SYN码

   第一次发送的SYN码是1

可以参考这个博客，写的比较清楚<https://blog.csdn.net/qzcsu/article/details/72861891>

#### 14、为什么TCP握手的时候是三段、不是两段或四段?两段或四段的可靠性会不会也没问题?

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主
要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手: Client什么都不能确认; Server 确认了对方发送正常，自已接收正常
第二次握手: Client 确认了:自己发送、接收正常，对方发送、接收正常; Server 确认了:对方发送正常，自己接收正常
第三次握手: Client 确认了:自己发送、接收正常，对方发送、接收正常; Server确认了:自己发送、接收正常，对方发送、接收正常
所以三次握手就能确认双发收发功能都正常，缺一不可。

#### 15、UDP的组播、广播?

1. 单播：网络节点之间的通信就好像是人们之间的对话一样。如果一个人对另外一个人说话，那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行。单播在网络中得到了广泛的应用，网络上绝大部分的数据都是以单播的形式传输的，只是一般网络用户不知道而已。例如，你在收发电子邮件、浏览网页时，必须与邮件服务器、Web服务器建立连接，此时使用的就是单播数据传输方式。但是通常使用“点对点通信”（Point to Point）代替“单播”，因为“单播”一般与“多播”和“广播”相对应使用。
2. 组播：“组播”也可以称为“多播”，在网络技术的应用并不是很多，网上视频会议、网上视频点播特别适合采用多播方式。因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率极低，是不可取的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的。采用多播方式，既可以实现一次传送所有目标节点的数据，也可以达到只对特定对象传送数据的目的。IP网络的多播一般通过多播IP地址来实现。多播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。Windows 2000中的DHCP管理器支持多播IP地址的自动分配。
     **组播的应用**

> 点对多点应用是指一个发送者，多个接收者的应用形式，这是最常见的多播应用形式。典型的应用包括：媒体广播、媒体推送、信息缓存、事件通知和状态监视等。

1. 多点对单点应用

> 多点对点应用是指多个发送者，一个接收者的应用形式。通常是双向请求响应应用，任何一端（多点或点）都有可能发起请求。典型应用包括：资源查找、数据收集、网络竞拍、信息询问等。

1. 多点对多点应用

> 多点对多点应用是指多个发送者和多个接收者的应用形式。通常，每个接收者可以接收多个发送者发送的数据，同时，每个发送者可以把数据发送给多个接收者。典型应用包括：多点会议、资源同步、并行处理、协同处理、远程学习、讨论组、分布式交互模拟（DIS）、多人游戏等。

3. 广播：“广播”在网络中的应用较多，如客户机通过DHCP自动获得IP地址的过程就是通过广播来实现的。但是同单播和多播相比，广播几乎占用了子网内网络的所有带宽。拿开会打一个比方吧，在会场上只能有一个人发言，想象一下如果所有的人同时都用麦克风发言，那会场上就会乱成一锅粥。集线器由于其工作原理决定了不可能过滤广播风暴，一般的交换机也没有这一功能，不过现在有的网络交换机（如全向的QS系列交换机）也有过滤广播风暴功能了，路由器本身就有隔离广播风暴的作用。广播风暴不能完全杜绝，但是只能在同一子网内传播，就好像喇叭的声音只能在同一会场内传播一样，因此在由几百台甚至上千台电脑构成的大中型局域网中，一般进行子网划分，就像将一个大厅用墙壁隔离成许多小厅一样，以达到隔离广播风暴的目的。在IP网络中，广播地址用IP地址“255.255.255.255”来表示，这个IP地址代表同一子网内所有的IP地址。

#### 16、HTTP协议?报文格式? GET和POST的区别?

1. HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。它是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

2. HTTP的请求报文包括：请求行(request line)、请求头部(header)、空行 和 请求数据(request data) 四个部分组成。

   **请求行**包括： 请求方法，URL(**包括参数信息**)，协议版本这些信息（GET/admin_ui/rdx/core/images/close.png HTTP/1.1）

   **请求头部(Header)**是一个个的key-value值，比如

   - Accept-Encoding: gzip, deflate

   **空行(CR+LF)：请求报文用空行表示header和请求数据的分隔**

   **请求数据**：GET方法没有携带数据， POST方法会携带一个body

3. GET和POST请求的区别:

   GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。

   POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据

   因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变

   详细可以看这个博客https://www.cnblogs.com/ranyonsue/p/5984001.html

#### 17、WebSocket了解吗?

**WebSocket**是一种在单个[TCP](https://baike.baidu.com/item/TCP)连接上进行[全双工](https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5)通信的协议。主要的业务需求场景是服务端主动向客户端推送信息的时候。在我现在做的这个系统里面主要有两个需求。第一就是我们的管理员权限需要获取实时的在线人数，我们一开始是用的轮询的方式，就是10s请求一次。第二就是我们做的这个系统需要获取各个水电站和水位点的小时数据，一开始也是用的轮询，后来因为这个数据量还有点大，就把两个一起都改成websocket了。

#### 18、系统登录，用户信息保存在哪里?登录是怎么做的?

以我们这个系统为例。

#### 19、写过接口吗?一个controller类，接口怎么写例如读取数据库的一个表，从上到下怎么写? controller类加什么注解?

#### 20、请求传入的参数是JSON字符串，怎么转换为实体类?序列化与反序列化的区别。