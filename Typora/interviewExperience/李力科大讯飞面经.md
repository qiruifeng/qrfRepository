[TOC]

#### 1、Java最新版本

我们目前用的是Java8，目前我知道的最新的版本到14了

#### 2、JDK和JRE的区别

JDK 是 Java Development Kit他是功能齐全的Java SDK。它包含了JRE拥有的一切，一般是开发的时候需要的。而JRE是Java的运行环境。它是运行已编译Java程序所需的所有内容的集合，包括JVM,Java类库，Java命令和一些其他的基础构建，不能用来创建新的程序。

如果只是跑一下Java的代码的话，一般用JRE就可以了。但是也不是绝对的，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢?因为应用程序服务器会将JSP转
换为Java servlet,并且需要使用JDK来编译servlet。

#### 3、程序写好了，如何部署到服务器

以我们的项目为例，分为前端和后台。先说前端，我们本地用的vue框架来写前端代码，版本更新时，我们先在本地进行打包，在node环境下运行npm run build指令，会在项目的target目录下生成dist文件。然后我们把这一份dist文件夹下的所有文件，复制到服务器的nginx或者tomcat的html文件夹下，即可完成前端的部署。后台的部署就是本地打一个jar包，然后在服务器上直接运行jar包就好。

#### 4、抽象类和接口的区别，抽象类和接口能否实例

首先接口和抽象类都不能被实例化，只有被另一个类实现或者继承，才能使用。区别有以下几点：

1. 接口中除了static、 final 变量，不能有其他变量，而抽象类中则不一定。
2. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
3. 从设计层面来说，抽象是对类的抽象，是一一种模板设计，而接口是对行为的抽象，是一种行为的规范。

#### 5、静态方法和实例方法的区别

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。


#### 6、String、StringBuffer、 StringBuilder, 的区别。

1. 可变性。

   简单的来说: String 类中使用final 关键字修饰字符数组来保存字符串，private final char value []， 所以String对象是不可变的。而StringBuilder与StringBuffer 都继承自AbstractStringBuilder 类，在AbstractStringBuilder中也是使用字符数组保存字符串char []value但是没有用final关键字修饰，所以这两种对象都是可变的。

2. 线程安全性

   String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是StringBuilder
   与StringBuffer的公共父类，定义了一一些字符串的基本操作，如expandCapacity、append、 insert、
   indexOf等公共方法。**StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁**，所以是线程安全
   的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

#### 7、MySql数据表，查有多少条数据，怎么查，SQL语句(返回数据条数，数值)

用count关键字，比如[select](https://www.baidu.com/s?wd=select&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) count(*) [from](https://www.baidu.com/s?wd=from&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) test where id=1。

#### 8、final修饰的类能不能继承、使用?

不可以。

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改;如果是
   引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为
   final方法。
3. 使用final方法的原因有两个。**第一个原因是把方法锁定，以防任何继承类修改它的含义**;第二个原
   因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能
   看不到内嵌调用带来的任何性能提升(现在的Java版本已经不需要使用final方法进行这些优化
   了)。类中所有的private方法都隐式地指定为final.

#### 9、了解操作系统吗?进程间的通信方式?

1. 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。

2. 有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。

3. 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

4. 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。

6. 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。

7. 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。

#### 10、多线程用过吗?

待补充内容

#### 11、了解锁吗?锁用到哪个场景?说到了乐观锁、悲观锁，解释一下?怎么用的?

1. 乐观锁。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**

   乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。

   （1） 数据版本机制

   　　实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。以版本号方式为例。

   　　版本号方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

   （2） CAS操作

   　　CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

   　　CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。

2. 悲观锁。**悲观锁适合写操作非常多的场景**，比如Java里面的同步原语synchronized关键字的实现就是悲观锁。

   认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一份数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁并发操作一定会出问题。

#### 12、TCP、UDP了解吗? (为什么 TCP是可靠的，UDP 是不可靠的? )

#### 13、解释一下TCP的三次握手?第一次发送的SYN码?断开的过程

#### 14、为什么TCP握手的时候是三段、不是两段或四段?两段或四段的可靠性会不会也没问题?

#### 15、UDP的组播、广播?

#### 16、HTTP协议?报文格式? GET和POST的区别?

#### 17、WebSocket了解吗?

#### 18、系统登录，用户信息保存在哪里?登录是怎么做的?

#### 19、写过接口吗?一个controller类，接口怎么写例如读取数据库的一个表，从上到下怎么写? controller类加什么注解?

#### 20、请求传入的参数是JSON字符串，怎么转换为实体类?序列化与反序列化的区别。